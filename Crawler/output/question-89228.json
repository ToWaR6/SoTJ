{"question": {"questionId": 89228, "tags": ["python", "shell", "command", "subprocess", "external", "python", "shell", "command", "subprocess", "external"], "userId": 17085, "selectedAnswer": 89243, "relatedQuestions": ["https://stackoverflow.com/questions/2232/calling-shell-commands-from-ruby", "https://stackoverflow.com/questions/59838/check-if-a-directory-exists-in-a-shell-script", "https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python", "https://stackoverflow.com/questions/226703/how-do-i-prompt-for-yes-no-cancel-input-in-a-linux-shell-script", "https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator", "https://stackoverflow.com/questions/493386/how-to-print-without-newline-or-space", "https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value", "https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean", "https://stackoverflow.com/questions/4651437/how-to-set-a-variable-to-the-output-of-a-command-in-bash", "https://stackoverflow.com/questions/5137497/find-current-directory-and-files-directory"], "answers": [{"userId": 11465, "comments": [{"content": "Is there a way to use variable substitution? IE I tried to do echo $PATH by using call([\"echo\", \"$PATH\"]), but it just echoed the literal string $PATH instead of doing any substitution. I know I could get the PATH environment variable, but I'm wondering if there is an easy way to have the command behave exactly as if I had executed it in bash.", "commentId": 52559086, "date": "2015-09-01 23:17:07Z", "userId": 3470632, "upvoteCount": 0}, {"content": "@KevinWheeler You'll have to use shell=True for that to work.", "commentId": 52598063, "date": "2015-09-02 20:38:24Z", "userId": 1399279, "upvoteCount": 0}, {"content": "@KevinWheeler You should NOT use shell=True, for this purpose Python comes with os.path.expandvars. In your case you can write: os.path.expandvars(\"$PATH\"). @SethMMorton please reconsider your comment -> Why not to use shell=True", "commentId": 55091938, "date": "2015-11-11 20:24:27Z", "userId": 1885518, "upvoteCount": 0}, {"content": "As of Python 3.5, it is suggested that you use subprocess.run instead of subprocess.call. docs.python.org/3/library/subprocess.html", "commentId": 63807915, "date": "2016-07-04 19:31:21Z", "userId": 2867076, "upvoteCount": 0}, {"content": "The example calls ls -l but does not give access to its output (stdout is not accessible).  I find that confusing --  you could use a command without stdout instead, such as touch.", "commentId": 77082261, "date": "2017-07-12 10:02:16Z", "userId": 1075152, "upvoteCount": 0}], "content": "\r\nLook at the subprocess module in the standard library:\n\nfrom subprocess import call\ncall([\"ls\", \"-l\"])\n\n\nThe advantage of subprocess vs. system is that it is more flexible (you can get the stdout, stderr, the \"real\" status code, better error handling, etc...).\n\nThe official documentation recommends the subprocess module over the alternative os.system():\n\n\n  The subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function [os.system()].\n\n\nThe \"Replacing Older Functions with the subprocess Module\" section in the subprocess documentation may have some helpful recipes.\n\nOfficial documentation on the subprocess module:\n\n\nPython 2 - subprocess\nPython 3 - subprocess\n\n    ", "answerId": 89243, "date": "2008-09-18 01:39:35Z", "upvoteCount": 3393}, {"userId": 1694, "comments": [{"content": "Nice answer/explanation.  How is this answer justifying Python's motto as described in this article ?  fastcompany.com/3026446/\u2026  \"Stylistically, Perl and Python have different philosophies. Perl\u2019s best known mottos is \" There\u2019s More Than One Way to Do It\". Python is designed to have one obvious way to do it\"  Seem like it should be the other way! In Perl I know only two ways to execute a command - using back-tick or open.", "commentId": 49018699, "date": "2015-05-26 21:16:27Z", "userId": 472485, "upvoteCount": 4}, {"content": "If using Python 3.5+, use subprocess.run(). docs.python.org/3.5/library/subprocess.html#subprocess.run", "commentId": 53820265, "date": "2015-10-07 16:37:18Z", "userId": 1398841, "upvoteCount": 0}, {"content": "What one typically needs to know is what is done with the child process's STDOUT and STDERR, because if they are ignored, under some (quite common) conditions, eventually the child process will issue a system call to write to STDOUT (STDERR too?) that would exceed the output buffer provided for the process by the OS, and the OS will cause it to block until some process reads from that buffer. So, with the currently recommended ways, subprocess.run(..), what exactly does \"This does not capture stdout or stderr by default.\" imply? What about subprocess.check_output(..) and STDERR?", "commentId": 62619897, "date": "2016-06-01 10:44:53Z", "userId": 1143274, "upvoteCount": 1}, {"content": "which of the commands you recommended block my script? i.e. if I want to run multiple commands in a for loop how do I do it without it blocking my python script? I don't care about the output of the command I just want to run lots of them.", "commentId": 80783837, "date": "2017-10-24 19:08:43Z", "userId": 1601580, "upvoteCount": 0}, {"content": "@phoenix I disagree. There is nothing preventing you from using os.system in python3 docs.python.org/3/library/os.html#os.system", "commentId": 82382413, "date": "2017-12-08 09:27:04Z", "userId": 7284582, "upvoteCount": 0}], "content": "\r\nHere's a summary of the ways to call external programs and the advantages and disadvantages of each:\n\n\nos.system(\"some_command with args\") passes the command and arguments to your system's shell.  This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection.  For example:  \n\nos.system(\"some_command < input_file | another_command > output_file\")  \n\n\nHowever, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, etc.  On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.  See the documentation.\nstream = os.popen(\"some_command with args\") will do the same thing as os.system except that it gives you a file-like object that you can use to access standard input/output for that process.  There are 3 other variants of popen that all handle the i/o slightly differently.  If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything.  See the documentation.\nThe Popen class of the subprocess module.  This is intended as a replacement for os.popen but has the downside of being slightly more complicated by virtue of being so comprehensive.  For example, you'd say:\n\nprint subprocess.Popen(\"echo Hello World\", shell=True, stdout=subprocess.PIPE).stdout.read()\n\n\ninstead of: \n\nprint os.popen(\"echo Hello World\").read()\n\n\nbut it is nice to have all of the options there in one unified class instead of 4 different popen functions.  See the documentation.\nThe call function from the subprocess module.  This is basically just like the Popen class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code.  For example:\n\nreturn_code = subprocess.call(\"echo Hello World\", shell=True)  \n\n\nSee the documentation.\nIf you're on Python 3.5 or later, you can use the new subprocess.run function, which is a lot like the above but even more flexible and returns a CompletedProcess object when the command finishes executing.\nThe os module also has all of the fork/exec/spawn functions that you'd have in a C program, but I don't recommend using them directly.\n\n\nThe subprocess module should probably be what you use.\n\nFinally please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. There are serious security implications if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:\n\nprint subprocess.Popen(\"echo %s \" % user_input, stdout=PIPE).stdout.read()\n\n\nand imagine that the user enters \"my mama didnt love me && rm -rf /\".\n    ", "answerId": 92395, "date": "2008-09-18 13:11:46Z", "upvoteCount": 2421}, {"userId": 9188, "comments": [{"content": ".readlines() reads all lines at once i.e., it blocks until the subprocess exits (closes its end of the pipe). To read in real time (if there is no buffering issues) you could: for line in iter(p.stdout.readline, ''): print line,", "commentId": 18336103, "date": "2012-11-16 14:12:18Z", "userId": 4279, "upvoteCount": 0}, {"content": "Could you elaborate on what you mean by \"if there is no buffering issues\"?  If the process blocks definitely, the subprocess call also blocks.  The same could happen with my original example as well. What else could happen with respect to buffering?", "commentId": 18358478, "date": "2012-11-17 13:25:15Z", "userId": 9188, "upvoteCount": 0}, {"content": "the child process may use block-buffering in non-interactive mode instead of line-buffering so p.stdout.readline() (note: no s at the end) won't see any data until the child fills its buffer. If the child doesn't produce much data then the output won't be in real time. See the second reason in Q: Why not just use a pipe (popen())?. Some workarounds are provided in this answer (pexpect, pty, stdbuf)", "commentId": 18358805, "date": "2012-11-17 13:51:25Z", "userId": 4279, "upvoteCount": 0}, {"content": "the buffering issue only matters if you want output in real time and doesn't apply to your code that doesn't print anything until all data is received", "commentId": 18358836, "date": "2012-11-17 13:53:26Z", "userId": 4279, "upvoteCount": 2}], "content": "\r\nI typically use:\n\nimport subprocess\n\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()\n\n\nYou are free to do what you want with the stdout data in the pipe.  In fact, you can simply omit those parameters (stdout= and stderr=) and it'll behave like os.system().\n    ", "answerId": 95246, "date": "2008-09-18 18:20:46Z", "upvoteCount": 249}, {"userId": 68998, "comments": [{"content": "i noticed a possible \"quirk\" with developing py2exe apps in pydev+eclipse. i was able to tell that the main script was not detached because eclipse's output window was not terminating; even if the script executes to completion it is still waiting for returns. but, when i tried compiling to a py2exe executable, the expected behavior occurs (runs the processes as detached, then quits). i am not sure, but the executable name is not in the process list anymore. this works for all approaches (os.system(\"start *\"), os.spawnl with os.P_DETACH, subprocs, etc.)", "commentId": 2615898, "date": "2010-04-09 08:09:26Z", "userId": 279468, "upvoteCount": 0}, {"content": "Windows gotcha: even though I spawned process with DETACHED_PROCESS, when I killed my Python daemon all ports opened by it wouldn't free until all spawned processes terminate. WScript.Shell solved all my problems. Example here: pastebin.com/xGmuvwSx", "commentId": 13051553, "date": "2012-04-16 10:04:33Z", "userId": 8338, "upvoteCount": 0}, {"content": "you might also need CREATE_NEW_PROCESS_GROUP flag. See Popen waiting for child process even when the immediate child has terminated", "commentId": 18336228, "date": "2012-11-16 14:16:42Z", "userId": 4279, "upvoteCount": 1}, {"content": "The following is incorrect: \"[o]n windows (win xp), the parent process will not finish until the longtask.py has finished its work\". The parent will exit normally, but the console window (conhost.exe instance) only closes when the last attached process exits, and the child may have inherited the parent's console. Setting DETACHED_PROCESS in creationflags avoids this by preventing the child from inheriting or creating a console. If you instead want a new console, use CREATE_NEW_CONSOLE (0x00000010).", "commentId": 54511646, "date": "2015-10-27 00:27:30Z", "userId": 205580, "upvoteCount": 1}, {"content": "I didn't mean that executing as a detached process is incorrect. That said, you may need to set the standard handles to files, pipes, or os.devnull because some console programs exit with an error otherwise. Create a new console when you want the child process to interact with the user concurrently with the parent process. It would be confusing to try to do both in a single window.", "commentId": 54543759, "date": "2015-10-27 17:37:15Z", "userId": 205580, "upvoteCount": 1}], "content": "\r\nSome hints on detaching the child process from the calling one (starting the child process in background).\n\nSuppose you want to start a long task from a CGI-script, that is the child process should live longer than the CGI-script execution process.\n\nThe classical example from the subprocess module docs is:\n\nimport subprocess\nimport sys\n\n# some code here\n\npid = subprocess.Popen([sys.executable, \"longtask.py\"]) # call subprocess\n\n# some more code here\n\n\nThe idea here is that you do not want to wait in the line 'call subprocess' until the longtask.py is finished. But it is not clear what happens after the line 'some more code here' from the example.\n\nMy target platform was freebsd, but the development was on windows, so I faced the problem on windows first.\n\nOn windows (win xp), the parent process will not finish until the longtask.py has finished its work. It is not what you want in CGI-script. The problem is not specific to Python, in PHP community the problems are the same.\n\nThe solution is to pass DETACHED_PROCESS Process Creation Flag to the underlying CreateProcess function in win API.\nIf you happen to have installed pywin32 you can import the flag from the win32process module, otherwise you should define it yourself:\n\nDETACHED_PROCESS = 0x00000008\n\npid = subprocess.Popen([sys.executable, \"longtask.py\"],\n                       creationflags=DETACHED_PROCESS).pid\n\n\n/* UPD 2015.10.27 @eryksun in a comment below notes, that the semantically correct flag is CREATE_NEW_CONSOLE (0x00000010) */\n\nOn freebsd we have another problem: when the parent process is finished, it finishes the child processes as well. And that is not what you want in CGI-script either. Some experiments showed that the problem seemed to be in sharing sys.stdout. And the working solution was the following:\n\npid = subprocess.Popen([sys.executable, \"longtask.py\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n\n\nI have not checked the code on other platforms and do not know the reasons of the behaviour on freebsd. If anyone knows, please share your ideas. Googling on starting background processes in Python does not shed any light yet.\n    ", "answerId": 2251026, "date": "2010-02-12 10:15:34Z", "upvoteCount": 153}, {"userId": 6222, "comments": [], "content": "\r\nI'd recommend using the subprocess module instead of os.system because it does shell escaping for you and is therefore much safer: http://docs.python.org/library/subprocess.html\n\nsubprocess.call(['ping', 'localhost'])\n\n    ", "answerId": 89255, "date": "2008-09-18 01:42:30Z", "upvoteCount": 91}, {"userId": 16203, "comments": [{"content": "popen is deprecated in favor of subprocess.", "commentId": 39233700, "date": "2014-08-08 00:22:35Z", "userId": 699159, "upvoteCount": 3}, {"content": "You can also save your result with the os.system call, since it works like the UNIX shell itself, like for example os.system('ls -l > test2.txt')", "commentId": 81287939, "date": "2017-11-07 23:19:20Z", "userId": 1751920, "upvoteCount": 0}], "content": "\r\nimport os\ncmd = 'ls -al'\nos.system(cmd)\n\n\nIf you want to return the results of the command, you can use os.popen. However, this is deprecated since version 2.6 in favor of the subprocess module, which other answers have covered well.\n    ", "answerId": 89238, "date": "2008-09-18 01:37:49Z", "upvoteCount": 86}, {"userId": 3926, "comments": [{"content": "What do you mean by \"the command isn't cleaned\"?", "commentId": 88347626, "date": "2018-06-03 17:10:31Z", "userId": 63550, "upvoteCount": 0}, {"content": "No idea what I meant nearly a decade ago (check the date!), but if I had to guess, it would be that there's no validation done.", "commentId": 88457934, "date": "2018-06-06 16:01:34Z", "userId": 3926, "upvoteCount": 0}], "content": "\r\nimport os\nos.system(\"your command\")\n\n\nNote that this is dangerous, since the command isn't cleaned. I leave it up to you to google for the relevant documentation on the 'os' and 'sys' modules. There are a bunch of functions (exec* and spawn*) that will do similar things.\n    ", "answerId": 89237, "date": "2008-09-18 01:37:24Z", "upvoteCount": 75}, {"userId": 463023, "comments": [], "content": "\r\nCheck the \"pexpect\" Python library, too.\n\nIt allows for interactive controlling of external programs/commands, even ssh, ftp, telnet, etc. You can just type something like:\n\nchild = pexpect.spawn('ftp 192.168.0.24')\n\nchild.expect('(?i)name .*: ')\n\nchild.sendline('anonymous')\n\nchild.expect('(?i)password')\n\n    ", "answerId": 3879406, "date": "2010-10-07 07:09:04Z", "upvoteCount": 50}, {"userId": 361023, "comments": [], "content": "\r\nI always use fabric for this things like:\n\nfrom fabric.operations import local\nresult = local('ls', capture=True)\nprint \"Content:/n%s\" % (result, )\n\n\nBut this seem to be a good tool: sh (Python subprocess interface).\n\nLook an example:\n\nfrom sh import vgdisplay\nprint vgdisplay()\nprint vgdisplay('-v')\nprint vgdisplay(v=True)\n\n    ", "answerId": 9676642, "date": "2012-03-13 00:12:54Z", "upvoteCount": 49}, {"userId": 5177604, "comments": [], "content": "\r\nThere are lots of different libraries which allow you to call external commands with Python. For each library I've given a description and shown an example of calling an external command. The command I used as the example is ls -l (list all files). If you want to find out more about any of the libraries I've listed and linked the documentation for each of them.\n\n\n  Sources:\n\n\n\nsubprocess: https://docs.python.org/3.5/library/subprocess.html\nshlex: https://docs.python.org/3/library/shlex.html\nos: https://docs.python.org/3.5/library/os.html\nsh: https://amoffat.github.io/sh/\nplumbum: https://plumbum.readthedocs.io/en/latest/\npexpect: https://pexpect.readthedocs.io/en/stable/\nfabric: http://www.fabfile.org/\nenvoy: https://github.com/kennethreitz/envoy\ncommands: https://docs.python.org/2/library/commands.html\n\n\n\n  \n    \n      These are all the libraries:\n    \n  \n\n\nHopefully this will help you make a decision on which library to use :)\n\n\n  subprocess\n\n\nSubprocess allows you to call external commands and connect them to their input/output/error pipes (stdin, stdout, and stderr). Subprocess is the default choice for running commands, but sometimes other modules are better.\n\nsubprocess.run([\"ls\", \"-l\"]) # Run command\nsubprocess.run([\"ls\", \"-l\"], stdout=subprocess.PIPE) # This will run the command and return any output\nsubprocess.run(shlex.split(\"ls -l\")) # You can also use the shlex library to split the command\n\n\n\n  os\n\n\nos is used for \"operating system dependent functionality\". It can also be used to call external commands with os.system and os.popen (Note: There is also a subprocess.popen). os will always run the shell and is a simple alternative for people who don't need to, or don't know how to use subprocess.run.\n\nos.system(\"ls -l\") # run command\nos.popen(\"ls -l\").read() # This will run the command and return any output\n\n\n\n  sh\n\n\nsh is a subprocess interface which lets you call programs as if they were functions. This is useful if you want to run a command multiple times.\n\nsh.ls(\"-l\") # Run command normally\nls_cmd = sh.Command(\"ls\") # Save command as a variable\nls_cmd() # Run command as if it were a function\n\n\n\n  plumbum\n\n\nplumbum is a library for \"script-like\" Python programs. You can call programs like functions as in sh. Plumbum is useful if you want to run a pipeline without the shell.\n\nls_cmd = plumbum.local(\"ls -l\") # get command\nls_cmd() # run command\n\n\n\n  pexpect\n\n\npexpect lets you spawn child applications, control them and find patterns in their output. This is a better alternative to subprocess for commands that expect a tty on Unix.\n\npexpect.run(\"ls -l\") # Run command as normal\nchild = pexpect.spawn('scp foo user@example.com:.') # Spawns child application\nchild.expect('Password:') # When this is the output\nchild.sendline('mypassword')\n\n\n\n  fabric\n\n\nfabric is a Python 2.5 and 2.7 library. It allows you to execute local and remote shell commands. Fabric is simple alternative for running commands in a secure shell (SSH)\n\nfabric.operations.local('ls -l') # Run command as normal\nfabric.operations.local('ls -l', capture = True) # Run command and receive output\n\n\n\n  envoy\n\n\nenvoy is known as \"subprocess for humans\". It is used as a convenience wrapper around the subprocess module.\n\nr = envoy.run(\"ls -l\") # Run command\nr.std_out # get output\n\n\n\n  commands\n\n\ncommands contains wrapper functions for os.popen, but it has been removed from Python 3 since subprocess is a better alternative.\n\nThe edit was based on J.F. Sebastian's comment.\n    ", "answerId": 40319875, "date": "2016-10-29 14:02:50Z", "upvoteCount": 45}, {"userId": 181337, "comments": [{"content": "Note that check_output requires a list rather than a string. If you don't rely on quoted spaces to make your call valid, the simplest, most readable way to do this is subprocess.check_output(\"ls -l /dev/null\".split()).", "commentId": 84050970, "date": "2018-01-30 18:18:54Z", "userId": 117471, "upvoteCount": 0}], "content": "\r\nIf you need the output from the command you are calling,\nthen you can use subprocess.check_output (Python 2.7+).\n\n>>> subprocess.check_output([\"ls\", \"-l\", \"/dev/null\"])\n'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'\n\n\nAlso note the shell parameter.\n\n\n  If shell is True, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user\u2019s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, glob, fnmatch, os.walk(), os.path.expandvars(), os.path.expanduser(), and shutil).\n\n    ", "answerId": 5824565, "date": "2011-04-28 20:29:29Z", "upvoteCount": 44}, {"userId": 1755213, "comments": [{"content": "Passing commands as strings is normally a bad idea", "commentId": 26001906, "date": "2013-07-23 18:29:11Z", "userId": 102441, "upvoteCount": 2}, {"content": "I think it's acceptable for hard-coded commands, if it increases readability.", "commentId": 34789609, "date": "2014-04-02 13:07:44Z", "userId": 51197, "upvoteCount": 2}], "content": "\r\nThis is how I run my commands. This code has everything you need pretty much\n\nfrom subprocess import Popen, PIPE\ncmd = \"ls -l ~/\"\np = Popen(cmd , shell=True, stdout=PIPE, stderr=PIPE)\nout, err = p.communicate()\nprint \"Return code: \", p.returncode\nprint out.rstrip(), err.rstrip()\n\n    ", "answerId": 13106558, "date": "2012-10-28 05:14:01Z", "upvoteCount": 40}, {"userId": 325365, "comments": [], "content": "\r\nWith Standard Library\n\nUse subprocess module:\n\nfrom subprocess import call\ncall(['ls', '-l'])\n\n\nIt is the recommended standard way. However, more complicated tasks (pipes, output, input, etc.) can be tedious to construct and write.\n\nNote: shlex.split can help you to parse the command for call and other subprocess functions in case you don't want (or you can't!) provide them in form of lists:\n\nimport shlex\nfrom subprocess import call\ncall(shlex.split('ls -l'))\n\n\nWith External Dependencies\n\nIf you do not mind external dependencies, use plumbum:\n\nfrom plumbum.cmd import ifconfig\nprint(ifconfig['wlan0']())\n\n\nIt is the best subprocess wrapper. It's cross-platform, i.e. it works on both Windows and Unix-like systems. Install by pip install plumbum.\n\nAnother popular library is sh:\n\nfrom sh import ifconfig\nprint(ifconfig('wlan0'))\n\n\nHowever, sh dropped Windows support, so it's not as awesome as it used to be. Install by pip install sh.\n    ", "answerId": 15954964, "date": "2013-04-11 17:17:53Z", "upvoteCount": 35}, {"userId": 233098, "comments": [], "content": "\r\nUpdate:\n\nsubprocess.run is the recommended approach as of Python 3.5 if your code does not need to maintain compatibility with earlier Python versions. It's more consistent and offers similar ease-of-use as Envoy. (Piping isn't as straightforward though. See this question for how.)\n\nHere's some examples from the docs.\n\nRun a process:\n\n>>> subprocess.run([\"ls\", \"-l\"])  # doesn't capture output\nCompletedProcess(args=['ls', '-l'], returncode=0)\n\n\nRaise on failed run:\n\n>>> subprocess.run(\"exit 1\", shell=True, check=True)\nTraceback (most recent call last):\n  ...\nsubprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\n\n\nCapture output:\n\n>>> subprocess.run([\"ls\", \"-l\", \"/dev/null\"], stdout=subprocess.PIPE)\nCompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,\nstdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\\n')\n\n\nOriginal answer:\n\nI recommend trying Envoy. It's a wrapper for subprocess, which in turn aims to replace the older modules and functions. Envoy is subprocess for humans.\n\nExample usage from the readme:\n\n>>> r = envoy.run('git config', data='data to pipe in', timeout=2)\n\n>>> r.status_code\n129\n>>> r.std_out\n'usage: git config [options]'\n>>> r.std_err\n''\n\n\nPipe stuff around too:\n\n>>> r = envoy.run('uptime | pbcopy')\n\n>>> r.command\n'pbcopy'\n>>> r.status_code\n0\n\n>>> r.history\n[<Response 'uptime'>]\n\n    ", "answerId": 13402722, "date": "2012-11-15 17:13:22Z", "upvoteCount": 33}, {"userId": 1275507, "comments": [], "content": "\r\nWithout the output of the result:\n\nimport os\nos.system(\"your command here\")\n\n\nWith output of the result:\n\nimport commands\ncommands.getoutput(\"your command here\")\nor\ncommands.getstatusoutput(\"your command here\")\n\n    ", "answerId": 16072857, "date": "2013-04-18 01:09:33Z", "upvoteCount": 30}, {"userId": 394370, "comments": [], "content": "\r\nThere is also Plumbum\n\n>>> from plumbum import local\n>>> ls = local[\"ls\"]\n>>> ls\nLocalCommand(<LocalPath /bin/ls>)\n>>> ls()\nu'build.py\\ndist\\ndocs\\nLICENSE\\nplumbum\\nREADME.rst\\nsetup.py\\ntests\\ntodo.txt\\n'\n>>> notepad = local[\"c:\\\\windows\\\\notepad.exe\"]\n>>> notepad()                                   # Notepad window pops up\nu''                                             # Notepad window is closed by user, command returns\n\n    ", "answerId": 26305089, "date": "2014-10-10 17:41:13Z", "upvoteCount": 21}, {"userId": 4482, "comments": [], "content": "\r\nhttps://docs.python.org/2/library/subprocess.html\n\n...or for a very simple command:\n\nimport os\nos.system('cat testfile')\n\n    ", "answerId": 89262, "date": "2008-09-18 01:43:30Z", "upvoteCount": 21}, {"userId": 14199, "comments": [], "content": "\r\nos.system is OK, but kind of dated.  It's also not very secure.  Instead, try subprocess.  subprocess does not call sh directly and is therefore more secure than os.system.\n\nGet more information here.\n    ", "answerId": 89304, "date": "2008-09-18 01:53:27Z", "upvoteCount": 20}, {"userId": 2781812, "comments": [{"content": "it's also deprecated.  use subprocess", "commentId": 56118340, "date": "2015-12-09 18:13:59Z", "userId": 16148, "upvoteCount": 1}], "content": "\r\nUse:\n\nimport os\n\ncmd = 'ls -al'\n\nos.system(cmd)\n\n\nos - This module provides a portable way of using operating system-dependent functionality.\n\nFor the more os functions, here is the documentation.\n    ", "answerId": 31114625, "date": "2015-06-29 11:34:22Z", "upvoteCount": 19}, {"userId": 263998, "comments": [], "content": "\r\nsubprocess.check_call is convenient if you don't want to test return values. It throws an exception on any error.\n    ", "answerId": 4728086, "date": "2011-01-18 19:21:44Z", "upvoteCount": 15}, {"userId": 541136, "comments": [], "content": "\r\n\n  Calling an external command in Python\n\n\nSimple, use subprocess.run, which returns a CompletedProcess object:\n\n>>> import subprocess\n>>> completed_process = subprocess.run('python --version')\nPython 3.6.1 :: Anaconda 4.4.0 (64-bit)\n>>> completed_process\nCompletedProcess(args='python --version', returncode=0)\n\n\nWhy?\n\nAs of Python 3.5, the documentation recommends subprocess.run:\n\n\n  The recommended approach to invoking subprocesses is to use the run() function for all use cases it can handle. For more advanced use cases, the underlying Popen interface can be used directly.\n\n\nHere's an example of the simplest possible usage - and it does exactly as asked:\n\n>>> import subprocess\n>>> completed_process = subprocess.run('python --version')\nPython 3.6.1 :: Anaconda 4.4.0 (64-bit)\n>>> completed_process\nCompletedProcess(args='python --version', returncode=0)\n\n\nrun waits for the command to successfully finish, then returns a CompletedProcess object. It may instead raise TimeoutExpired (if you give it a timeout= argument) or CalledProcessError (if it fails and you pass check=True).\n\nAs you might infer from the above example, stdout and stderr both get piped to your own stdout and stderr by default.\n\nWe can inspect the returned object and see the command that was given and the returncode:\n\n>>> completed_process.args\n'python --version'\n>>> completed_process.returncode\n0\n\n\nCapturing output\n\nIf you want to capture the output, you can pass subprocess.PIPE to the appropriate stderr or stdout:\n\n>>> cp = subprocess.run('python --version', \n                        stderr=subprocess.PIPE, \n                        stdout=subprocess.PIPE)\n>>> cp.stderr\nb'Python 3.6.1 :: Anaconda 4.4.0 (64-bit)\\r\\n'\n>>> cp.stdout\nb''\n\n\n(I find it interesting and slightly counterintuitive that the version info gets put to stderr instead of stdout.)\n\nPass a command list\n\nOne might easily move from manually providing a command string (like the question suggests) to providing a string built programmatically. Don't build strings programmatically. This is a potential security issue. It's better to assume you don't trust the input. \n\n>>> import textwrap\n>>> args = ['python', textwrap.__file__]\n>>> cp = subprocess.run(args, stdout=subprocess.PIPE)\n>>> cp.stdout\nb'Hello there.\\r\\n  This is indented.\\r\\n'\n\n\nNote, only args should be passed positionally.\n\nFull Signature\n\nHere's the actual signature in the source and as shown by help(run):\n\n\ndef run(*popenargs, input=None, timeout=None, check=False, **kwargs):\n\n\n\nThe popenargs and kwargs are given to the Popen constructor. input can be a string of bytes (or unicode, if specify encoding or universal_newlines=True) that will be piped to the subprocess's stdin.\n\nThe documentation describes timeout= and check=True better than I could:\n\n\n  The timeout argument is passed to Popen.communicate(). If the timeout\n  expires, the child process will be killed and waited for. The\n  TimeoutExpired exception will be re-raised after the child process has\n  terminated.\n  \n  If check is true, and the process exits with a non-zero exit code, a\n  CalledProcessError exception will be raised. Attributes of that\n  exception hold the arguments, the exit code, and stdout and stderr if\n  they were captured.\n\n\nand this example for check=True is better than one I could come up with:\n\n\n>>> subprocess.run(\"exit 1\", shell=True, check=True)\nTraceback (most recent call last):\n  ...\nsubprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\n\n\n\nExpanded Signature\n\nHere's an expanded signature, as given in the documentation:\n\n\nsubprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, \nshell=False, cwd=None, timeout=None, check=False, encoding=None, \nerrors=None)\n\n\n\nNote that this indicates that only the args list should be passed positionally. So pass the remaining arguments as keyword arguments.\n\nPopen\n\nWhen use Popen instead? I would struggle to find use-case based on the arguments alone. Direct usage of Popen would, however, give you access to its methods, including poll, 'send_signal', 'terminate', and 'wait'.\n\nHere's the Popen signature as given in the source. I think this is the most precise encapsulation of the information (as opposed to help(Popen)):\n\ndef __init__(self, args, bufsize=-1, executable=None,\n             stdin=None, stdout=None, stderr=None,\n             preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,\n             shell=False, cwd=None, env=None, universal_newlines=False,\n             startupinfo=None, creationflags=0,\n             restore_signals=True, start_new_session=False,\n             pass_fds=(), *, encoding=None, errors=None):\n\n\nBut more informative is the Popen documentation:\n\n\nsubprocess.Popen(args, bufsize=-1, executable=None, stdin=None,\n                 stdout=None, stderr=None, preexec_fn=None, close_fds=True,\n                 shell=False, cwd=None, env=None, universal_newlines=False,\n                 startupinfo=None, creationflags=0, restore_signals=True,\n                 start_new_session=False, pass_fds=(), *, encoding=None, errors=None)\n\n  \n  Execute a child program in a new process. On POSIX, the class uses\n  os.execvp()-like behavior to execute the child program. On Windows,\n  the class uses the Windows CreateProcess() function. The arguments to\n  Popen are as follows.\n\n\nUnderstanding the remaining documentation on Popen will be left as an exercise for the reader.\n    ", "answerId": 46815111, "date": "2017-10-18 16:37:52Z", "upvoteCount": 15}, {"userId": 246735, "comments": [{"content": "What do you mean by \"Anyone runs the kwrite not being a subprocess\"?", "commentId": 88350869, "date": "2018-06-03 20:14:54Z", "userId": 63550, "upvoteCount": 0}], "content": "\r\nThere is another difference here which is not mentioned previously.\n\nsubprocess.Popen executes the <command> as a subprocess. In my case, I need to execute file <a> which needs to communicate with another program, <b>. \n\nI tried subprocess, and execution was successful. However <b> could not communicate with <a>.\nEverything is normal when I run both from the terminal.\n\nOne more: \n(NOTE: kwrite behaves different from other applications. If you try the below with Firefox, the results will not be the same.)\n\nIf you try os.system(\"kwrite\"), program flow freezes until the user closes kwrite. To overcome that I tried instead os.system(konsole -e kwrite). This time program continued to flow, but kwrite became the subprocess of the console.\n\nAnyone runs the kwrite not being a subprocess (i.e. in the system monitor it must appear at the leftmost edge of the tree).\n    ", "answerId": 2030768, "date": "2010-01-08 21:11:30Z", "upvoteCount": 15}, {"userId": 1449929, "comments": [], "content": "\r\nos.system does not allow you to store results, so if you want to store results in some list or something subprocess.call works.\n    ", "answerId": 10988365, "date": "2012-06-11 22:28:35Z", "upvoteCount": 14}, {"userId": 117268, "comments": [], "content": "\r\nI tend to use subprocess together with shlex (to handle escaping of quoted strings):\n\n>>> import subprocess, shlex\n>>> command = 'ls -l \"/your/path/with spaces/\"'\n>>> call_params = shlex.split(command)\n>>> print call_params\n[\"ls\", \"-l\", \"/your/path/with spaces/\"]\n>>> subprocess.call(call_params)\n\n    ", "answerId": 23391049, "date": "2014-04-30 14:37:04Z", "upvoteCount": 14}, {"userId": 929095, "comments": [], "content": "\r\nShameless plug, I wrote a library for this :P\nhttps://github.com/houqp/shell.py\n\nIt's basically a wrapper for popen and shlex for now. It also supports piping commands so you can chain commands easier in Python. So you can do things like:\n\nex('echo hello shell.py') | \"awk '{print $2}'\"\n\n    ", "answerId": 23416345, "date": "2014-05-01 20:49:01Z", "upvoteCount": 12}, {"userId": 1417123, "comments": [], "content": "\r\nYou can use Popen, and then you can check the procedure's status:\n\nfrom subprocess import Popen\n\nproc = Popen(['ls', '-l'])\nif proc.poll() is None:\n    proc.kill()\n\n\nCheck out subprocess.Popen.\n    ", "answerId": 11507283, "date": "2012-07-16 15:16:24Z", "upvoteCount": 12}, {"userId": 3089950, "comments": [], "content": "\r\nTo fetch the network id from the openstack neutron:\n\n#!/usr/bin/python\nimport os\nnetid= \"nova net-list | awk '/ External / { print $2 }'\"\ntemp=os.popen(netid).read()  /* here temp also contains new line (\\n) */\nnetworkId=temp.rstrip()\nprint(networkId)\n\n\nOutput of nova net-list\n\n+--------------------------------------+------------+------+\n| ID                                   | Label      | CIDR |\n+--------------------------------------+------------+------+\n| 431c9014-5b5d-4b51-a357-66020ffbb123 | test1      | None |\n| 27a74fcd-37c0-4789-9414-9531b7e3f126 | External   | None |\n| 5a2712e9-70dc-4b0e-9281-17e02f4684c9 | management | None |\n| 7aa697f5-0e60-4c15-b4cc-9cb659698512 | Internal   | None |\n+--------------------------------------+------------+------+\n\n\nOutput of print(networkId)\n\n27a74fcd-37c0-4789-9414-9531b7e3f126\n\n    ", "answerId": 38477871, "date": "2016-07-20 09:50:01Z", "upvoteCount": 11}, {"userId": 2476373, "comments": [], "content": "\r\nUnder Linux, in case you would like to call an external command that will execute independently (will keep running after the python script terminates), you can use a simple queue as task spooler or the at command\n\nAn example with task spooler:\n\nimport os\nos.system('ts <your-command>')\n\n\nNotes about task spooler (ts): \n\n\nYou could set the number of concurrent processes to be run (\"slots\") with:\n\nts -S <number-of-slots>\nInstalling ts doesn't requires admin privileges. You can download and compile it from source with a simple make, add it to your path and you're done.\n\n    ", "answerId": 40824514, "date": "2016-11-27 00:15:34Z", "upvoteCount": 11}, {"userId": 605022, "comments": [], "content": "\r\nI quite like shell_command for its simplicity.  It's built on top of the subprocess module.\n\nHere's an example from the docs:\n\n>>> from shell_command import shell_call\n>>> shell_call(\"ls *.py\")\nsetup.py  shell_command.py  test_shell_command.py\n0\n>>> shell_call(\"ls -l *.py\")\n-rw-r--r-- 1 ncoghlan ncoghlan  391 2011-12-11 12:07 setup.py\n-rw-r--r-- 1 ncoghlan ncoghlan 7855 2011-12-11 16:16 shell_command.py\n-rwxr-xr-x 1 ncoghlan ncoghlan 8463 2011-12-11 16:17 test_shell_command.py\n0\n\n    ", "answerId": 11940294, "date": "2012-08-13 18:36:32Z", "upvoteCount": 11}, {"userId": 2081554, "comments": [{"content": "Deadlock potential: use the .communicate method instead", "commentId": 63894693, "date": "2016-07-07 02:15:41Z", "userId": 3750257, "upvoteCount": 1}], "content": "\r\nHere are my two cents: In my view, this is the best practice when dealing with external commands...\n\nThese are the return values from the execute method...\n\npass, stdout, stderr = execute([\"ls\",\"-la\"],\"/home/user/desktop\")\n\n\nThis is the execute method...\n\ndef execute(cmdArray,workingDir):\n\n    stdout = ''\n    stderr = ''\n\n    try:\n        try:\n            process = subprocess.Popen(cmdArray,cwd=workingDir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=1)\n        except OSError:\n            return [False, '', 'ERROR : command(' + ' '.join(cmdArray) + ') could not get executed!']\n\n        for line in iter(process.stdout.readline, b''):\n\n            try:\n                echoLine = line.decode(\"utf-8\")\n            except:\n                echoLine = str(line)\n\n            stdout += echoLine\n\n        for line in iter(process.stderr.readline, b''):\n\n            try:\n                echoLine = line.decode(\"utf-8\")\n            except:\n                echoLine = str(line)\n\n            stderr += echoLine\n\n    except (KeyboardInterrupt,SystemExit) as err:\n        return [False,'',str(err)]\n\n    process.stdout.close()\n\n    returnCode = process.wait()\n    if returnCode != 0 or stderr != '':\n        return [False, stdout, stderr]\n    else:\n        return [True, stdout, stderr]\n\n    ", "answerId": 33118899, "date": "2015-10-14 07:12:51Z", "upvoteCount": 9}, {"userId": 5397845, "comments": [], "content": "\r\nIn Windows you can just import the subprocess module and run external commands by calling subprocess.Popen(), subprocess.Popen().communicate() and subprocess.Popen().wait() as below:\n\n# Python script to run a command line\nimport subprocess\n\ndef execute(cmd):\n    \"\"\"\n        Purpose  : To execute a command and return exit status\n        Argument : cmd - command to execute\n        Return   : exit_code\n    \"\"\"\n    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    (result, error) = process.communicate()\n\n    rc = process.wait()\n\n    if rc != 0:\n        print \"Error: failed to execute command:\", cmd\n        print error\n    return result\n# def\n\ncommand = \"tasklist | grep python\"\nprint \"This process detail: \\n\", execute(command)\n\n\nOutput:\n\nThis process detail:\npython.exe                     604 RDP-Tcp#0                  4      5,660 K\n\n    ", "answerId": 37877635, "date": "2016-06-17 09:14:24Z", "upvoteCount": 9}, {"userId": 789213, "comments": [{"content": "Is this going to be deprecated in python 3.0?", "commentId": 33655136, "date": "2014-03-04 14:16:18Z", "userId": 719016, "upvoteCount": 2}], "content": "\r\nVery simplest way to run any command and get the result back:\n\nfrom commands import getstatusoutput\n\ntry:\n    return getstatusoutput(\"ls -ltr\")\nexcept Exception, e:\n    return None\n\n    ", "answerId": 11644161, "date": "2012-07-25 06:51:50Z", "upvoteCount": 8}, {"userId": 2679465, "comments": [], "content": "\r\nHere is calling an external command and return or print the command's output:\n\nPython Subprocess check_output is good for\n\n\n  Run command with arguments and return its output as a byte string.\n\n\nimport subprocess\nproc = subprocess.check_output('ipconfig /all')\nprint proc\n\n    ", "answerId": 39969619, "date": "2016-10-11 02:26:49Z", "upvoteCount": 7}, {"userId": 869482, "comments": [], "content": "\r\nThere are a lot of different ways to run external commands in Python,\nand all of them have their own plus sides and drawbacks.\n\nMy colleagues and me have been writing Python system administration tools, so we need to run a lot of external commands, and sometimes you want them to block or run asynchronously, time-out, update every second, etc.\n\nThere are also different ways of handling the return code and errors,\nand you might want to parse the output, and provide new input (in an expect kind of style). Or you will need to redirect stdin, stdout and stderr to run in a different tty (e.g., when using screen).\n\nSo you will probably have to write a lot of wrappers around the external command. So here is a Python module which we have written which can handle\nalmost anything you would want, and if not, it's very flexible so you can easily extend it:\n\nhttps://github.com/hpcugent/vsc-base/blob/master/lib/vsc/utils/run.py\n    ", "answerId": 16062355, "date": "2013-04-17 14:10:06Z", "upvoteCount": 6}, {"userId": 547050, "comments": [], "content": "\r\nUse:\n\nimport subprocess\n\np = subprocess.Popen(\"df -h\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]\nprint p.split(\"\\n\")\n\n\nIt gives nice output which is easier to work with:\n\n['Filesystem      Size  Used Avail Use% Mounted on',\n '/dev/sda6        32G   21G   11G  67% /',\n 'none            4.0K     0  4.0K   0% /sys/fs/cgroup',\n 'udev            1.9G  4.0K  1.9G   1% /dev',\n 'tmpfs           387M  1.4M  386M   1% /run',\n 'none            5.0M     0  5.0M   0% /run/lock',\n 'none            1.9G   58M  1.9G   3% /run/shm',\n 'none            100M   32K  100M   1% /run/user',\n '/dev/sda5       340G  222G  100G  69% /home',\n '']\n\n    ", "answerId": 38012358, "date": "2016-06-24 11:29:00Z", "upvoteCount": 6}, {"userId": 1119779, "comments": [], "content": "\r\nJust to add to the discussion, if you include using a Python console, you can call external commands from IPython. While in the IPython prompt, you can call shell commands by prefixing '!'. You can also combine Python code with the shell, and assign the output of shell scripts to Python variables.\n\nFor instance:\n\nIn [9]: mylist = !ls\n\nIn [10]: mylist\nOut[10]:\n['file1',\n 'file2',\n 'file3',]\n\n    ", "answerId": 17202916, "date": "2013-06-19 23:18:34Z", "upvoteCount": 5}, {"userId": 1546844, "comments": [{"content": "answer with run function was added in 2015 year. You repeated it. I think it was a reason of down vote", "commentId": 72595849, "date": "2017-03-11 18:27:50Z", "userId": 2699806, "upvoteCount": 1}], "content": "\r\nFor Python 3.5+ it is recommended that you use the run function from the subprocess module. This returns a CompletedProcess object, from which you can easily obtain the output as well as return code.\n\nfrom subprocess import PIPE, run\n\ncommand = ['echo', 'hello']\nresult = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True)\nprint(result.returncode, result.stdout, result.stderr)\n\n    ", "answerId": 36058314, "date": "2016-03-17 10:48:32Z", "upvoteCount": 5}, {"userId": 5771451, "comments": [], "content": "\r\nThere are many ways to call a command.\n\n\nFor example:\n\n\nif and.exe needs two parameters. In cmd we can call sample.exe use this:\n   and.exe 2 3 and it show 5 on screen.\n\nIf we use a Python script to call and.exe, we should do like..\n\n\nos.system(cmd,...)\n\n\nos.system((\"and.exe\" + \" \" + \"2\" + \" \" + \"3\"))\n\nos.popen(cmd,...)\n\n\nos.popen((\"and.exe\" + \" \" + \"2\" + \" \" + \"3\"))\n\nsubprocess.Popen(cmd,...)\n\n\nsubprocess.Popen((\"and.exe\" + \" \" + \"2\" + \" \" + \"3\"))\n\n\n\nIt's too hard, so we can join cmd with a space:\n\nimport os\ncmd = \" \".join(exename,parameters)\nos.popen(cmd)\n\n    ", "answerId": 39447501, "date": "2016-09-12 09:44:09Z", "upvoteCount": 5}, {"userId": 658247, "comments": [], "content": "\r\nA simple way is to use the os module:\n\nimport os\nos.system('ls')\n\n\nAlternatively you can also use the subprocess module\n\nimport subprocess\nsubprocess.check_call('ls')\n\n\nIf you want the result to be stored in a variable try:\n\nimport subprocess\nr = subprocess.check_output('ls')\n\n    ", "answerId": 25476624, "date": "2014-08-24 21:46:12Z", "upvoteCount": 4}, {"userId": 4527213, "comments": [], "content": "\r\nUsing the Popen function of the subprocess Python module is the simplest way of running Linux commands. In that, the Popen.communicate() function will give your commands output. For example\n\nimport subprocess\n\n..\nprocess = subprocess.Popen(..)   # Pass command and arguments to the function\nstdout, stderr = process.communicate()   # Get command output and error\n..\n\n    ", "answerId": 31618111, "date": "2015-07-24 19:12:21Z", "upvoteCount": 4}, {"userId": 8468899, "comments": [{"content": "According to docs.python.org/2/library/\u2026, \"shell=True\" may raise a security concern.", "commentId": 85785785, "date": "2018-03-20 18:54:34Z", "userId": 5458157, "upvoteCount": 0}, {"content": "@Nick Predley: noted, but \"shell=False\" doesn't perform the desired function. What specifically are the security concerns and what's the alternative? Please let me know asap: I do not wish to post anything which may cause problems for anyone viewing this.", "commentId": 85832373, "date": "2018-03-21 19:49:03Z", "userId": 8468899, "upvoteCount": 0}], "content": "\r\nAs an example (in Linux):\n\nimport subprocess\nsubprocess.run('mkdir test.dir', shell=True)\n\n\nThis creates test.dir in the current directory.\nNote that this also works:\n\nimport subprocess\nsubprocess.call('mkdir test.dir', shell=True)\n\n\nThe equivalent code using os.system is:\n\nimport os\nos.system('mkdir test.dir')\n\n\nBest practice would be to use subprocess instead of os, with .run favored over .call. \nAll you need to know about subprocess is here.\nAlso, note that all Python documentation is available for download from here. I downloaded the PDF packed as .zip. I mention this because there's a nice overview of the os module in tutorial.pdf (page 81). Besides, it's an authoritative resource for Python coders.\n    ", "answerId": 48548332, "date": "2018-01-31 17:42:38Z", "upvoteCount": 4}, {"userId": 746837, "comments": [{"content": "your code may lose data when the subprocess exits while there is some data is buffered. Read until EOF instead, see teed_call()", "commentId": 50758994, "date": "2015-07-13 18:52:13Z", "userId": 4279, "upvoteCount": 2}], "content": "\r\nAfter some research, I have the following code which works very well for me. It basically prints both stdout and stderr in real time. Hope it helps someone else who needs it.\n\nstdout_result = 1\nstderr_result = 1\n\n\ndef stdout_thread(pipe):\n    global stdout_result\n    while True:\n        out = pipe.stdout.read(1)\n        stdout_result = pipe.poll()\n        if out == '' and stdout_result is not None:\n            break\n\n        if out != '':\n            sys.stdout.write(out)\n            sys.stdout.flush()\n\n\ndef stderr_thread(pipe):\n    global stderr_result\n    while True:\n        err = pipe.stderr.read(1)\n        stderr_result = pipe.poll()\n        if err == '' and stderr_result is not None:\n            break\n\n        if err != '':\n            sys.stdout.write(err)\n            sys.stdout.flush()\n\n\ndef exec_command(command, cwd=None):\n    if cwd is not None:\n        print '[' + ' '.join(command) + '] in ' + cwd\n    else:\n        print '[' + ' '.join(command) + ']'\n\n    p = subprocess.Popen(\n        command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd\n    )\n\n    out_thread = threading.Thread(name='stdout_thread', target=stdout_thread, args=(p,))\n    err_thread = threading.Thread(name='stderr_thread', target=stderr_thread, args=(p,))\n\n    err_thread.start()\n    out_thread.start()\n\n    out_thread.join()\n    err_thread.join()\n\n    return stdout_result + stderr_result\n\n    ", "answerId": 22395328, "date": "2014-03-14 02:59:05Z", "upvoteCount": 3}, {"userId": 950708, "comments": [], "content": "\r\nUse subprocess.call:\n\n\n\nfrom subprocess import call\n\n# using list\ncall([\"echo\", \"Hello\", \"world\"])\n\n# single string argument varies across platforms so better split it\ncall(\"echo Hello world\".split(\" \"))\n\n    ", "answerId": 23030076, "date": "2014-04-12 11:58:23Z", "upvoteCount": 3}, {"userId": 527813, "comments": [], "content": "\r\nI would recommend the following method 'run' and it will help us in getting STDOUT, STDERR and exit status as dictionary; The caller of this can read the dictionary return by 'run' method to know the actual state of process. \n\n  def run (cmd):\n       print \"+ DEBUG exec({0})\".format(cmd)\n       p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, shell=True)\n       (out, err) = p.communicate()\n       ret        = p.wait()\n       out        = filter(None, out.split('\\n'))\n       err        = filter(None, err.split('\\n'))\n       ret        = True if ret == 0 else False\n       return dict({'output': out, 'error': err, 'status': ret})\n  #end\n\n    ", "answerId": 36913076, "date": "2016-04-28 11:18:22Z", "upvoteCount": 3}, {"userId": 6634322, "comments": [{"content": "Why capital \"I\" in \"Import\"?", "commentId": 88351533, "date": "2018-06-03 20:55:26Z", "userId": 63550, "upvoteCount": 1}, {"content": "I corrected it, thanks, I juste didn't noticed it before", "commentId": 88527903, "date": "2018-06-08 12:06:38Z", "userId": 6634322, "upvoteCount": 0}], "content": "\r\nIt can be this simple:\n\nimport os\ncmd = \"your command\"\nos.system(cmd)\n\n    ", "answerId": 50101887, "date": "2018-04-30 13:47:17Z", "upvoteCount": 3}, {"userId": 284795, "comments": [{"content": "Deprecated doesn't only mean \"isn't developed anymore\" but also \"you are discouraged from using this\". Deprecated features may break anytime, may be removed anytime, or may dangerous. You should never use this in important code. Deprecation is merely a better way than removing a feature immediately, because it gives programmers the time to adapt and replace their deprecated functions.", "commentId": 22988454, "date": "2013-04-19 08:07:01Z", "userId": 1076143, "upvoteCount": 0}, {"content": "Just to prove my point: \"Deprecated since version 2.6: The commands module has been removed in Python 3. Use the subprocess module instead.\"", "commentId": 22988607, "date": "2013-04-19 08:14:32Z", "userId": 1076143, "upvoteCount": 3}, {"content": "It's not dangerous! The Python devs are careful only to break features between major releases (ie. between 2.x and 3.x). I've been using the commands module since 2004's Python 2.4. It works the same today in Python 2.7.", "commentId": 23118138, "date": "2013-04-23 16:09:04Z", "userId": 284795, "upvoteCount": 0}, {"content": "With dangerous, I didn't mean that it may be removed anytime (that's a different problem), neither did I say that it is dangerous to use this specific module. However it may become dangerous if a security vulnerability is discovered but the module isn't further developed or maintained. (I don't want to say that this module is or isn't vulnerable to security issues, just talking about deprecated stuff in general)", "commentId": 23118703, "date": "2013-04-23 16:23:36Z", "userId": 1076143, "upvoteCount": 0}], "content": "\r\nThe subprocess module described above by Eli is very powerful, but the syntax to make a bog-standard system call and inspect its output, is unnecessarily prolix.\n\nThe easiest way to make a system call is with the commands module (Linux only).\n\n> import commands\n> commands.getstatusoutput(\"grep matter alice-in-wonderland.txt\")\n(0, \"'Then it doesn't matter which way you go,' said the Cat.\")\n\n\nThe first item in the tuple is the return code of the process. The second item is its standard output (and standard error, merged).\n\n\n\nThe Python devs have 'deprecated' the commands module, but that doesn't mean you shouldn't use it. Only that they're not developing it anymore, which is okay, because it's already perfect (at its small but important function).\n    ", "answerId": 16089689, "date": "2013-04-18 17:39:50Z", "upvoteCount": 2}, {"userId": 4521562, "comments": [{"content": "You'll get unexpected results passing an arg with space. Using repr(arg) instead of str(arg) might help by the mere coincidence that python and sh escape quotes the same way", "commentId": 87797622, "date": "2018-05-17 12:08:29Z", "userId": 169828, "upvoteCount": 0}], "content": "\r\nOften, I use the following function for external commands, and this is especially handy for long running processes. The below method tails process output while it is running and returns the output, raises an exception if process fails.\n\nIt comes out if the process is done using the poll() method on the process.\n\ndef exec_long_running_proc(command, args):\n    cmd = \"{} {}\".format(command, \" \".join(str(arg) for arg in args))\n    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n\n    # Poll process for new output until finished\n    while True:\n        nextline = process.stdout.readline()\n        if nextline == '' and process.poll() is not None:\n            break\n        sys.stdout.write(nextline)\n        sys.stdout.flush()\n\n    output = process.communicate()[0]\n    exitCode = process.returncode\n\n    if (exitCode == 0):\n        return output\n    else:\n        raise Exception(command, exitCode, output)\n\n\nYou can invoke it like this:\n\nexec_long_running_proc(command = \"hive\", args=[\"-f\", hql_path])\n\n    ", "answerId": 49441486, "date": "2018-03-23 02:30:43Z", "upvoteCount": 2}, {"userId": 596370, "comments": [], "content": "\r\nCalling an external command in Python\n\nA simple way to call an external command is using os.system(...). And this function returns the exit value of the command. But the drawback is we won't get stdout and stderr.\n\nret = os.system('some_cmd.sh')\nif ret != 0 :\n    print 'some_cmd.sh execution returned failure'\n\n\nCalling an external command in Python in background\n\nsubprocess.Popen provides more flexibility for running an external command rather than using os.system. We can start a command in the background and wait for it to finish. And after that we can get the stdout and stderr.\n\nproc = subprocess.Popen([\"./some_cmd.sh\"], stdout=subprocess.PIPE)\nprint 'waiting for ' + str(proc.pid)\nproc.wait()\nprint 'some_cmd.sh execution finished'\n(out, err) = proc.communicate()\nprint 'some_cmd.sh output : ' + out\n\n\nCalling a long running external command in Python in the background and stop after some time\n\nWe can even start a long running process in the background using subprocess.Popen and kill it after sometime once its task is done.\n\nproc = subprocess.Popen([\"./some_long_run_cmd.sh\"], stdout=subprocess.PIPE)\n# Do something else\n# Now some_long_run_cmd.sh exeuction is no longer needed, so kill it\nos.system('kill -15 ' + str(proc.pid))\nprint 'Output : ' proc.communicate()[0]\n\n    ", "answerId": 49644672, "date": "2018-04-04 06:57:44Z", "upvoteCount": 2}, {"userId": 2260553, "comments": [], "content": "\r\nI have written a wrapper to handle errors and redirecting output and other stuff.\n\nimport shlex\nimport psutil\nimport subprocess\n\ndef call_cmd(cmd, stdout=sys.stdout, quiet=False, shell=False, raise_exceptions=True, use_shlex=True, timeout=None):\n    \"\"\"Exec command by command line like 'ln -ls \"/var/log\"'\n    \"\"\"\n    if not quiet:\n        print(\"Run %s\", str(cmd))\n    if use_shlex and isinstance(cmd, (str, unicode)):\n        cmd = shlex.split(cmd)\n    if timeout is None:\n        process = subprocess.Popen(cmd, stdout=stdout, stderr=sys.stderr, shell=shell)\n        retcode = process.wait()\n    else:\n        process = subprocess.Popen(cmd, stdout=stdout, stderr=sys.stderr, shell=shell)\n        p = psutil.Process(process.pid)\n        finish, alive = psutil.wait_procs([p], timeout)\n        if len(alive) > 0:\n            ps = p.children()\n            ps.insert(0, p)\n            print('waiting for timeout again due to child process check')\n            finish, alive = psutil.wait_procs(ps, 0)\n        if len(alive) > 0:\n            print('process {} will be killed'.format([p.pid for p in alive]))\n            for p in alive:\n                p.kill()\n            if raise_exceptions:\n                print('External program timeout at {} {}'.format(timeout, cmd))\n                raise CalledProcessTimeout(1, cmd)\n        retcode = process.wait()\n    if retcode and raise_exceptions:\n        print(\"External program failed %s\", str(cmd))\n        raise subprocess.CalledProcessError(retcode, cmd)\n\n\nYou can call it like this:\n\ncmd = 'ln -ls \"/var/log\"'\nstdout = 'out.txt'\ncall_cmd(cmd, stdout)\n\n    ", "answerId": 46921537, "date": "2017-10-24 23:30:20Z", "upvoteCount": 0}, {"userId": 7812314, "comments": [], "content": "\r\nIf you need to call a shell command from a Python notebook (like Jupyter, Zeppelin, Databricks, or Google Cloud Datalab) you can just use the ! prefix.\n\nFor example,\n\n!ls -ilF\n\n    ", "answerId": 50242060, "date": "2018-05-08 20:49:55Z", "upvoteCount": 0}], "content": "\r\n\r\nHow can I call an external command (as if I'd typed it at the Unix shell or Windows command prompt) from within a Python script?\n    ", "comments": [], "date": "2008-09-18 01:35:30Z", "title": "Calling an external command in Python", "favoriteCount": 1202, "upvoteCount": 3531}, "users": [{"pseudo": "igaurav", "reputation": 1924, "userId": 2174742}, {"pseudo": "freshWoWer", "reputation": 18393, "userId": 17085}, {"pseudo": "Peter Mortensen", "reputation": 12506, "userId": 63550}, {"pseudo": "David Cournapeau", "reputation": 50771, "userId": 11465}, {"pseudo": "the Tin Man", "reputation": 129147, "userId": 128421}, {"pseudo": "Eli Courtwright", "reputation": 110117, "userId": 1694}, {"pseudo": "Jim Fasarakis Hilliard", "reputation": 64856, "userId": 4952130}, {"pseudo": "EmmEff", "reputation": 4637, "userId": 9188}, {"pseudo": "rstackhouse", "reputation": 1194, "userId": 726378}, {"pseudo": "newtover", "reputation": 21086, "userId": 68998}, {"pseudo": "cincodenada", "reputation": 2102, "userId": 306323}, {"pseudo": "sirwart", "reputation": 1411, "userId": 6222}, {"pseudo": "Patrick M", "reputation": 6213, "userId": 1146608}, {"pseudo": "Alexandra Franks", "reputation": 1840, "userId": 16203}, {"pseudo": "nimish", "reputation": 2376, "userId": 3926}, {"pseudo": "athanassis", "reputation": 631, "userId": 463023}, {"pseudo": "Eric", "reputation": 62773, "userId": 102441}, {"pseudo": "Jorge E. Cardona", "reputation": 67387, "userId": 361023}, {"pseudo": "Tom Fuller", "reputation": 2884, "userId": 5177604}, {"pseudo": "Facundo Casco", "reputation": 5865, "userId": 181337}, {"pseudo": "Usman Khan", "reputation": 425, "userId": 1755213}, {"pseudo": "Honza Javorek", "reputation": 2966, "userId": 325365}, {"pseudo": "Community", "reputation": 1, "userId": -1}, {"pseudo": "Joe", "reputation": 9830, "userId": 233098}, {"pseudo": "Zuckonit", "reputation": 493, "userId": 1275507}, {"pseudo": "stuckintheshuck", "reputation": 1484, "userId": 394370}, {"pseudo": "Jonathan Callen", "reputation": 8546, "userId": 946915}, {"pseudo": "Ben Hoffstein", "reputation": 82773, "userId": 4482}, {"pseudo": "Martin W", "reputation": 1063, "userId": 14199}, {"pseudo": "Priyankara", "reputation": 510, "userId": 2781812}, {"pseudo": "cdunn2001", "reputation": 11224, "userId": 263998}, {"pseudo": "Aaron Hall", "reputation": 136882, "userId": 541136}, {"pseudo": "Atinc Delican", "reputation": 159, "userId": 246735}, {"pseudo": "Mariusz Jamro", "reputation": 18458, "userId": 342473}, {"pseudo": "Saurabh Bangad", "reputation": 149, "userId": 1449929}, {"pseudo": "Emil Stenstr\u00f6m", "reputation": 6185, "userId": 117268}, {"pseudo": "houqp", "reputation": 383, "userId": 929095}, {"pseudo": "admire", "reputation": 229, "userId": 1417123}, {"pseudo": "IRSHAD", "reputation": 926, "userId": 3089950}, {"pseudo": "yuval", "reputation": 1986, "userId": 2476373}, {"pseudo": "mdwhatcott", "reputation": 2275, "userId": 605022}, {"pseudo": "urosjarc", "reputation": 532, "userId": 2081554}, {"userId": 5397845, "reputation": 734, "pseudo": "Swadhikar C"}, {"userId": 789213, "reputation": 1171, "pseudo": "Garfield"}, {"userId": 2679465, "reputation": 1598, "pseudo": "Rajiv Sharma"}, {"userId": 869482, "reputation": 4422, "pseudo": "Jens Timmerman"}, {"userId": 547050, "reputation": 4052, "pseudo": "David Okwii"}, {"userId": 1119779, "reputation": 1390, "pseudo": "imagineerThat"}, {"userId": 1546844, "reputation": 5881, "pseudo": "Chiel ten Brinke"}, {"userId": 5771451, "reputation": 89, "pseudo": "liuyip"}, {"userId": 658247, "reputation": 390, "pseudo": "amehta"}, {"userId": 4527213, "reputation": 113, "pseudo": "Asif Hasnain"}, {"userId": 8468899, "reputation": 0, "pseudo": "user8468899"}, {"userId": 746837, "reputation": 1606, "pseudo": "Jake W"}, {"userId": 950708, "reputation": 967, "pseudo": "andruso"}, {"userId": 527813, "reputation": 2241, "pseudo": "Viswesn"}, {"userId": 6634322, "reputation": 51, "pseudo": "Samadi Salahedine"}, {"userId": 284795, "reputation": 75057, "pseudo": "Colonel Panic"}, {"userId": 4521562, "reputation": 108, "pseudo": "am5"}, {"userId": 596370, "reputation": 5285, "pseudo": "rashok"}, {"userId": 2260553, "reputation": 533, "pseudo": "Asav Patel"}, {"userId": 7812314, "reputation": 526, "pseudo": "dportman"}]}